<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>moon&#39;blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-10T09:20:47.069Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>moon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排序链表</title>
    <link href="http://yoursite.com/2019/08/10/%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/08/10/排序链表/</id>
    <published>2019-08-10T09:05:00.000Z</published>
    <updated>2019-08-10T09:20:47.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h1><p>属于leetcode里腾讯精选练习（50）里面关于<strong>排序</strong>的一道题，难度为<strong>中等</strong>，原链接<a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-list/</a> 。（使用<strong>python3</strong>解决）</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在 <strong><em>O</em>(<em>n</em> log <em>n</em>) 时间复杂度和常数级空间复杂度</strong>下，对<strong>链表</strong>进行排序。</p><p><strong>示例1 :</strong></p><blockquote><p>输入: 4-&gt;2-&gt;1-&gt;3<br>输出: 1-&gt;2-&gt;3-&gt;4</p></blockquote><p><strong>示例2 :</strong></p><blockquote><p>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0<br>输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</p></blockquote><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>两路归并排序，且采用递归分割再归并方式。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>分割环节</strong>：将链表从中间断开，再不断递归断开新产生的短链表。</p><ul><li>使用 fast，slow 快慢双指针法，慢指针每次走一个节点，快指针每次走两个节点，当快指针指向最后一个节点时慢指针指向中间节点的<strong>前一个节点</strong></li><li>将链表从中间断开，slow.next = None</li><li>继续将已经分割的两个链表递归分割，输入条件为每个链表的首节点</li><li><strong>递归终止条件</strong>：当当前链表只有一个节点时，直接返回此节点，head.next=None</li></ul><p><strong>合并环节</strong>：将两个链表合并为一个有序链表</p><ul><li>初始化一个节点 h 作为有序链表头部</li><li>用两个指针 left，right 分别指向待合并链表的首节点</li><li>比较两指针处的节点值大小，由小到大加入有序链表中，两指针交替前进，直到两个链表排序完成</li><li>返回有序链表的头节点，即 h.next</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 递归终止</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        slow, fast = head, head.next</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            fast, slow = fast.next.next, slow.next</span><br><span class="line">        <span class="comment"># 从中间断开</span></span><br><span class="line">        mid, slow.next = slow.next, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归分割已断开的两链表</span></span><br><span class="line">        left, right = self.sortList(head), self.sortList(mid)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 合并两链表</span></span><br><span class="line">        h = res = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">if</span> left.val &lt; right.val:</span><br><span class="line">                h.next, left = left, left.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                h.next, right = right, right.next</span><br><span class="line">            h = h.next</span><br><span class="line">        <span class="comment"># 剩余元素全部加入</span></span><br><span class="line">        h.next = left <span class="keyword">if</span> left <span class="keyword">else</span> right</span><br><span class="line">        <span class="keyword">return</span> res.next</span><br></pre></td></tr></table></figure><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><p><img src="https://ae01.alicdn.com/kf/He552d8aafe76408caade9f6a8e17dbd1e.png" alt="方法一提交"></p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：O(nlogn)，分割次数 O(logn) x (快慢指针搜索次数 O(n) + merge 过程 O(n) )。</p><p>空间复杂度：O(1)，只需要几个指针进行交换。（严格来讲应该为<strong>O(logn)</strong>，因为每次递归都会新建几个指针）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然看到了有采用非递归的形式解决问题的，但是无奈看不太懂，所以也就没有也出来。本题的关键难度在于同时要满足时间复杂度和空间复杂度的要求，思路难想明白，总体来说比较复杂。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;排序链表&quot;&gt;&lt;a href=&quot;#排序链表&quot; class=&quot;headerlink&quot; title=&quot;排序链表&quot;&gt;&lt;/a&gt;排序链表&lt;/h1&gt;&lt;p&gt;属于leetcode里腾讯精选练习（50）里面关于&lt;strong&gt;排序&lt;/strong&gt;的一道题，难度为&lt;strong&gt;中等
      
    
    </summary>
    
      <category term="腾讯精选练习" scheme="http://yoursite.com/categories/%E8%85%BE%E8%AE%AF%E7%B2%BE%E9%80%89%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="刷题" scheme="http://yoursite.com/tags/%E5%88%B7%E9%A2%98/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>买卖股票的最佳时机 II</title>
    <link href="http://yoursite.com/2019/08/09/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II/"/>
    <id>http://yoursite.com/2019/08/09/买卖股票的最佳时机-II/</id>
    <published>2019-08-09T10:25:00.000Z</published>
    <updated>2019-08-09T12:20:55.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h1><p>属于leetcode里腾讯精选练习（50）里面关于<strong>贪心算法</strong>的一道题，难度为<strong>简单</strong>，原链接<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</a> 。（使用<strong>python3</strong>解决）</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p><strong>注意</strong>：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例1 :</strong></p><blockquote><p>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p></blockquote><p><strong>示例2 :</strong></p><blockquote><p>输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p></blockquote><p><strong>示例3 :</strong></p><blockquote><p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p></blockquote><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>找到每一段价格相差最大的时间段，将每一段的收益加起来即可。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>从头开始找，只要当前价格比明天价格低就记为买入点，如果价格持续下降到最后则不买入</li><li>在买入点之后如果价格上升，继续往后，直到价格下降的前一天记为卖出点；如果价格持续上升到最后一天，则记最后一天为卖出点</li><li>卖出股票后记录收益，继续寻找下一个买入点和卖出点直到无法满足一次完整的买入和卖出（即买入点时间大于或等于了最后一天）</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 本次交易股票买入点</span></span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 本次交易股票卖出点</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 总收入</span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(p &lt; len(prices)<span class="number">-1</span>):</span><br><span class="line">            <span class="comment"># 只要当前价格大于明天价格，买入和卖出整体后移一天</span></span><br><span class="line">            <span class="keyword">if</span> prices[p] &gt;= prices[i]:</span><br><span class="line">                p += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 找到价格上升的最后一天</span></span><br><span class="line">            <span class="keyword">elif</span> i &lt; len(prices)<span class="number">-1</span> <span class="keyword">and</span> prices[i] &lt;= prices[i+<span class="number">1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sum += prices[i] - prices[p]</span><br><span class="line">                p = i + <span class="number">1</span></span><br><span class="line">                i = p + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><p><img src="https://pic.superbed.cn/item/5d4d417b451253d1780a5e3c.png" alt="方法一提交"></p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：O(n)，所有操作均在一次循环中完成。</p><p>空间复杂度：O(1)，只需要常量的空间。</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>递增买入和卖出，只要相邻两天价格收益为正，即完成交易。关键点在于可以在同一天买入和卖出，并且没有手续费。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>只要当前价格比后一天价格低，即买入并在后一天卖出（价格连续上涨的话会在同一天卖出又买入，但是没有手续费）</li><li>价格如果有下降，则不买入</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        profit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            tmp = prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> tmp &gt; <span class="number">0</span>:</span><br><span class="line">                profit += tmp</span><br><span class="line">        <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure><h3 id="提交-1"><a href="#提交-1" class="headerlink" title="提交"></a>提交</h3><p><img src="https://pic.superbed.cn/item/5d4d46fb451253d1780a9ea3.png" alt="方法二提交"></p><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：O(n)，一次循环计算出结果</p><p>空间复杂度：O(1)，只需要常量的空间</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然是关于贪心算法的一道题，但是解题方法中只有方法一用到了贪心算法的思路，或许还有更优的解题方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;买卖股票的最佳时机-II&quot;&gt;&lt;a href=&quot;#买卖股票的最佳时机-II&quot; class=&quot;headerlink&quot; title=&quot;买卖股票的最佳时机 II&quot;&gt;&lt;/a&gt;买卖股票的最佳时机 II&lt;/h1&gt;&lt;p&gt;属于leetcode里腾讯精选练习（50）里面关于&lt;stro
      
    
    </summary>
    
      <category term="腾讯精选练习" scheme="http://yoursite.com/categories/%E8%85%BE%E8%AE%AF%E7%B2%BE%E9%80%89%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="刷题" scheme="http://yoursite.com/tags/%E5%88%B7%E9%A2%98/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="贪心算法" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>合并K个排序链表</title>
    <link href="http://yoursite.com/2019/08/08/%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/08/08/合并K个排序链表/</id>
    <published>2019-08-08T04:35:00.000Z</published>
    <updated>2019-08-08T04:48:57.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="合并K个排序链表"><a href="#合并K个排序链表" class="headerlink" title="合并K个排序链表"></a>合并K个排序链表</h1><p>属于leetcode里腾讯精选练习（50）里面关于<strong>堆</strong>的一道题，难度为<strong>困难</strong>，原链接<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists/</a> 。（使用<strong>python3</strong>解决）</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>合并 <em>k</em> 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><p><strong>示例 :</strong></p><blockquote><p>输入:<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p></blockquote><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>暴力解决，将所有的元素统一排序，再生成新链表返回。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>依次遍历所有链表，取出所有链表节点值放入一个列表中</li><li>排序该列表，此时排序方法可不同</li><li>遍历排序后的列表，生成一个新链表并返回</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        self.nodes = []</span><br><span class="line">        <span class="comment"># 新链表的头节点和尾节点</span></span><br><span class="line">        head = point = ListNode(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                self.nodes.append(node.val)</span><br><span class="line">                node = node.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> sorted(self.nodes):</span><br><span class="line">            point.next = ListNode(x)</span><br><span class="line">            point = point.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><p><img src="https://pic.superbed.cn/item/5d4b8d85451253d178edeb07.png" alt="方法一提交"></p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：O(nlogn)，n为节点总数</p><ul><li>遍历所有的节点需花费O(n)时间</li><li>一个稳定的排序算法需要O(nlogn)时间（以内置的sorted函数为例）</li><li>遍历新列表同时生成新链表花费O(n)时间</li></ul><p>空间复杂度：O(n)</p><ul><li>排序获得排好序的列表花费O(n)空间</li><li>生成新的有序链表花费O(n)空间</li></ul><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>借助上篇文章提到的heapq库，使用堆结构进行排序。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>借助heapq库构建一个空的小顶堆</li><li>遍历所有链表节点，依次加入堆中</li><li>依次弹出堆顶元素，同时添加进新建的有序链表中</li><li>返回新建有序列表</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        self.nodes = []</span><br><span class="line">        <span class="comment"># 新链表的头节点和尾节点</span></span><br><span class="line">        head = point = ListNode(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                heapq.heappush(self.nodes, node.val)</span><br><span class="line">                node = node.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(len(self.nodes)):</span><br><span class="line">            point.next = ListNode(heapq.heappop(self.nodes))</span><br><span class="line">            point = point.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><h3 id="提交-1"><a href="#提交-1" class="headerlink" title="提交"></a>提交</h3><p><img src="https://pic3.superbed.cn/item/5d4b9dda451253d178f041f1.png" alt="方法二提交"></p><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：O(nlogn)，n为节点总数（此处时间复杂度有待详细计算）</p><ul><li>遍历所有节点花费O(n)时间</li><li>同时生成小顶堆花费O(nlogn)时间（实际上应该要小于该时间，因为logn的n是基于当前堆的大小，而堆大小是从零开始最终为n的）</li><li>生成新链表花费O(n)时间（这个时间也不准确，因为在堆弹出堆顶元素后，剩下堆元素需要调整以符合堆结构，这个过程也需要时间）</li></ul><p>空间复杂度：O(n)</p><ul><li>生成小顶堆花费O(n)空间</li><li>新建有序链表花费O(n)空间</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述两种方法在时间复杂度上差别不大，比较理想的方法应该是采用分治算法，目前也在研究怎么使用分治算法去解决这道题。另外分析不同算法的时空间复杂度也是一个问题，需要对相应的数据结构以及算法有比较深的了解，并且数学推理能力也要比较好才行。总之继续学习吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;合并K个排序链表&quot;&gt;&lt;a href=&quot;#合并K个排序链表&quot; class=&quot;headerlink&quot; title=&quot;合并K个排序链表&quot;&gt;&lt;/a&gt;合并K个排序链表&lt;/h1&gt;&lt;p&gt;属于leetcode里腾讯精选练习（50）里面关于&lt;strong&gt;堆&lt;/strong&gt;的一道
      
    
    </summary>
    
      <category term="腾讯精选练习" scheme="http://yoursite.com/categories/%E8%85%BE%E8%AE%AF%E7%B2%BE%E9%80%89%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="刷题" scheme="http://yoursite.com/tags/%E5%88%B7%E9%A2%98/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="堆" scheme="http://yoursite.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>数组中的第K个最大元素</title>
    <link href="http://yoursite.com/2019/08/06/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2019/08/06/数组中的第K个最大元素/</id>
    <published>2019-08-06T12:12:00.000Z</published>
    <updated>2019-08-08T02:12:30.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h1><p>属于leetcode里腾讯精选练习（50）里面关于堆的一道题，难度为中等，原链接<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/</a> 。（使用<strong>python3</strong>解决）</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在未排序的数组中找到第 <strong>k</strong> 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: [3,2,1,5,6,4] 和 k = 2<br>输出: 5</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4<br>输出: 4</p></blockquote><p>说明:<br>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>直接使用内置的排序算法，由于内置sorted算法默认是升序排列的，所以需要第K个最大元素，则返回排序后的倒数第K个元素。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> sorted(nums)[-k]</span><br></pre></td></tr></table></figure><p>提交也通过，结果如下：</p><p><img src="https://pic3.superbed.cn/item/5d496a46451253d178a63a91.png" alt="第一版提交"></p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>由于是需要找到第K大的元素，所以我们可以根据堆的性质，构建一个小顶堆，令该堆的大小为K，则在将所有元素堆化后，堆顶元素即为第K大的元素，堆底的值则为最大值。与内置的排序方法比较，内置的sorted函数时间复杂度是O(nlogn)，而使用堆后，由于每次插入堆的时间复杂度都是O(logk)，插入n次，最终为O(nlogk)。具体实现如下：</p><ul><li>借助heapq库构建一个小顶堆，具体使用方法自行查阅。</li><li>先将数组的前K个元素直接添加进堆中。</li><li>剩余的元素依次判断是否大于堆顶元素，是则加入堆中，并且删除此时堆顶元素保证堆长度为K。</li><li>数组遍历完后，此时堆中保留了最大的K个元素，并且按升序排列，堆顶元素即为第K大元素，返回即可。</li></ul><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        heap = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[:k]:</span><br><span class="line">            heapq.heappush(heap, num)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[k:]:</span><br><span class="line">            <span class="keyword">if</span> num &gt; heap[<span class="number">0</span>]:</span><br><span class="line">                heapq.heappush(heap, num)</span><br><span class="line">                heapq.heappop(heap)</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>提交结果：</p><p><img src="https://ae01.alicdn.com/kf/Hc18ad8a8d7e74c9bb95336eadd6c0497T.png" alt></p><hr><p>堆的结构类似于二叉树，根据其中元素大小不同又可以将其分为大顶堆和小顶堆。利用别人已经写好的结构去解决问题是很快，但是还是得深入背后去了解其实现方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组中的第K个最大元素&quot;&gt;&lt;a href=&quot;#数组中的第K个最大元素&quot; class=&quot;headerlink&quot; title=&quot;数组中的第K个最大元素&quot;&gt;&lt;/a&gt;数组中的第K个最大元素&lt;/h1&gt;&lt;p&gt;属于leetcode里腾讯精选练习（50）里面关于堆的一道题，难度为
      
    
    </summary>
    
      <category term="腾讯精选练习" scheme="http://yoursite.com/categories/%E8%85%BE%E8%AE%AF%E7%B2%BE%E9%80%89%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="刷题" scheme="http://yoursite.com/tags/%E5%88%B7%E9%A2%98/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="堆" scheme="http://yoursite.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>有效的括号</title>
    <link href="http://yoursite.com/2019/08/05/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>http://yoursite.com/2019/08/05/有效的括号/</id>
    <published>2019-08-05T07:23:00.000Z</published>
    <updated>2019-08-08T02:11:27.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h1><p>属于leetcode里腾讯精选练习（50）里面关于栈的一道题，难度为简单，原链接<a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parentheses/</a> 。（使用<strong>python3</strong>解决）</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ul><blockquote><p>注意空字符串可被认为是有效字符串。</p></blockquote><p>示例 1:</p><blockquote><p>输入: “()”<br>输出: true</p></blockquote><p>示例 2:</p><blockquote><p>输入: “()[]{}”<br>输出: true</p></blockquote><p>示例 3:</p><blockquote><p>输入: “(]”<br>输出: false</p></blockquote><p>示例 4:</p><blockquote><p>输入: “([)]”<br>输出: false</p></blockquote><p>示例 5:</p><blockquote><p>输入: “{[]}”<br>输出: true</p></blockquote><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>看到题目，第一时间就想到以前学过的使用栈来判断括号的案例，大致思路为：按字符遍历待测字符串，将字符串中的左括号依次加入栈中，如果遇到右括号则取出当前栈顶元素判断是否与该右括号匹配，遍历完后如果此时栈为空则表示所有左括号都找到了与之匹配的右括号，即表示有效，反之则表示无效。具体如下：</p><ul><li>借用栈后入先出的特性，按字符遍历待测字符串</li><li>如果当前字符为左开的小、中、大括号，加入栈中，继续选取后续字符</li><li>如果不是左开的括号，再判断当前栈是否为空，是则表示无效</li><li>如果当前栈不为空，且当前字符为右开的括号，则取出此时栈顶元素依次与当前字符比较，判断是否为配对的括号，是则继续选取后续字符，否则表示无效</li><li>所有字符遍历完后，判断当前栈是否为空，是则表示每一个左开的括号都找到了匹配的右括号，否则表示无效</li></ul><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">if</span> char == <span class="string">'('</span> <span class="keyword">or</span> char == <span class="string">'['</span> <span class="keyword">or</span> char == <span class="string">'&#123;'</span>:</span><br><span class="line">                    self.stack.append(char)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="keyword">not</span> self.stack:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">elif</span> char == <span class="string">')'</span>:</span><br><span class="line">                    <span class="keyword">if</span> self.stack.pop() == <span class="string">'('</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">elif</span> char == <span class="string">']'</span>:</span><br><span class="line">                    <span class="keyword">if</span> self.stack.pop() == <span class="string">'['</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">elif</span> char == <span class="string">'&#125;'</span>:</span><br><span class="line">                    <span class="keyword">if</span> self.stack.pop() == <span class="string">'&#123;'</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.stack:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>虽然在各种测试都通过，但是提交没有通过，甚至连提交结果显示的那个例子经测试也是通过的，很奇怪而且没有找到解决的办法。</p><p><img src="https://pic.superbed.cn/item/5d47ccf9451253d17873c200.png" alt="第一版提交"><br><img src="https://pic.superbed.cn/item/5d47cdb2451253d17873deea.png" alt="第一版测试"></p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>在题解处看到了<a href="https://leetcode-cn.com/problems/valid-parentheses/solution/you-xiao-de-gua-hao-by-leetcode/" target="_blank" rel="noopener">官方的解答</a>，解决方案有两种，第一种跟我上述方法一思路差不多，不多说。第二种是将字符串中已经配对好的括号依次删除，直到最后看是否还剩下了未成对的单括号。</p><p>代码很简洁，具体如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="string">'&#123;&#125;'</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">'()'</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">'[]'</span> <span class="keyword">in</span> s:</span><br><span class="line">            s = s.replace(<span class="string">'&#123;&#125;'</span>, <span class="string">''</span>)</span><br><span class="line">            s = s.replace(<span class="string">'[]'</span>, <span class="string">''</span>)</span><br><span class="line">            s = s.replace(<span class="string">'()'</span>, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> s == <span class="string">''</span></span><br></pre></td></tr></table></figure><p>提交通过，结果如下：</p><p><img src="https://pic.superbed.cn/item/5d47d66c451253d17874ca16.png" alt="第二版提交"></p><hr><p>看了很多别人写的解决方法，发现自己写的真的是很糟糕，代码冗长，全是if判断，还有未知的问题，没有充分利用python的内置结构和方法等等，总之还有很多需要学习的地方。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;有效的括号&quot;&gt;&lt;a href=&quot;#有效的括号&quot; class=&quot;headerlink&quot; title=&quot;有效的括号&quot;&gt;&lt;/a&gt;有效的括号&lt;/h1&gt;&lt;p&gt;属于leetcode里腾讯精选练习（50）里面关于栈的一道题，难度为简单，原链接&lt;a href=&quot;https://l
      
    
    </summary>
    
      <category term="腾讯精选练习" scheme="http://yoursite.com/categories/%E8%85%BE%E8%AE%AF%E7%B2%BE%E9%80%89%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="栈" scheme="http://yoursite.com/tags/%E6%A0%88/"/>
    
      <category term="刷题" scheme="http://yoursite.com/tags/%E5%88%B7%E9%A2%98/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>最小栈</title>
    <link href="http://yoursite.com/2019/08/04/%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <id>http://yoursite.com/2019/08/04/最小栈/</id>
    <published>2019-08-04T07:00:00.000Z</published>
    <updated>2019-08-08T02:10:11.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h1><p>属于leetcode里腾讯精选练习（50）里面关于栈的一道题，难度为简单，原链接<a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/min-stack/</a> 。（使用<strong>python3</strong>解决）</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设计一个支持 push，pop，top 操作，并能在<strong>常数时间</strong>内检索到最小元素的栈。</p><ul><li>push(x) – 将元素 x 推入栈中。</li><li>pop() – 删除栈顶的元素。</li><li>top() – 获取栈顶元素。</li><li>getMin() – 检索栈中的最小元素。</li></ul><p>示例:</p><blockquote><p>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.</p></blockquote><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>根据题目，在python中数组比较适合栈的结构，而且数组拥有append、pop等方法适合实现栈的压入和删除功能，内置的min函数可以检索到栈中最小元素。至于获取栈顶元素，原本想的是直接pop得到，但是发现题目要求获取是得到值，并不删除栈顶元素，第一反应是pop后再append回去，后来发现是自己傻了，直接返回数组最后一个不就好了吗（即list[-1]）。然后再加上一些栈是否为空的判断完成了方法一的解答，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:      <span class="comment"># 开始通过len(self.stack)判断是否为空，但是这样会多执行一次len函数</span></span><br><span class="line">            self.stack.pop()    <span class="comment"># 之所以会加上判断栈是否为空，是因为pop方法在list为空时执行时会报错</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="comment"># x = self.stack.pop()</span></span><br><span class="line">            <span class="comment"># self.stack.append(x)</span></span><br><span class="line">            <span class="comment"># return x</span></span><br><span class="line">            <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> min(self.stack)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>提交结果如下，明显效率不是很高，还有待优化。</p><p><img src="https://ae01.alicdn.com/kf/Hd66a2cc5cb2e4c2aa9164570b1ab71bfe.jpg" alt="第一版提交"></p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>方法一的时间消耗很大，主要是因为在获取栈最小值时采用系统内置的min函数获取，而该函数时间复杂度为O(n)，并没有达到题目要求的常数时间，所以导致整体时间消耗很大。在参考了其他人的解题思路后，最主要的问题便是怎么记录下栈中的最小值，从而不用查找一部得到，经过修改得到方法二。大致思路如下：</p><ul><li>另设置一个辅助栈min_stack，依次存储当前stack中最小的值<ul><li>push：每当有新的值进来时，压入stack，再判断辅助栈是否为空，若为空直接添加进辅助栈，若不为空则判断新值是否<strong>小于或等于</strong>辅助栈栈顶值，是则加入辅助栈，既保证辅助栈内栈顶元素永远为当前栈最小值。</li><li>pop：每当删除一个栈顶元素时，如果栈非空，则删除栈顶元素，同时判断该元素是否为当前栈最小值，即是否等于辅助栈栈顶元素，若相等则连同辅助栈栈顶元素一起删除，同样保证辅助栈内栈顶元素永远为当前栈最小值。</li><li>getMin：由于辅助栈栈顶存储着当前栈的最小值，所以只要当前栈非空，返回辅助栈栈顶元素即可。</li></ul></li><li>min_stack栈作用是按时间顺序依次存储当前stack栈的最小值，并且如果stack栈中将当前最小值删除了，辅助栈内也会同步删除。</li><li>由于辅助栈栈顶元素即为当前栈最小值，该值为min_stack[-1]，时间复杂度为O(1)，满足题要求。</li></ul><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 存放所有数据</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        <span class="comment"># 依次存放当前最小数据</span></span><br><span class="line">        self.min_stack = []</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.min_stack <span class="keyword">or</span> x &lt;= self.min_stack[<span class="number">-1</span>]:</span><br><span class="line">            self.min_stack.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="keyword">if</span> self.stack.pop() == self.min_stack[<span class="number">-1</span>]:</span><br><span class="line">                self.min_stack.pop()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> self.min_stack[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>提交结果如下，可以看到时间上比起方法一好了很多，但是明显还是有改进的地方。</p><p><img src="https://pic2.superbed.cn/item/5d467b68451253d1784dce74.jpg" alt="第二版提交"></p><hr><p>暂时想到上述两种方法，后续如果还发现了更好的解题方法将会继续改进下去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最小栈&quot;&gt;&lt;a href=&quot;#最小栈&quot; class=&quot;headerlink&quot; title=&quot;最小栈&quot;&gt;&lt;/a&gt;最小栈&lt;/h1&gt;&lt;p&gt;属于leetcode里腾讯精选练习（50）里面关于栈的一道题，难度为简单，原链接&lt;a href=&quot;https://leetcode-
      
    
    </summary>
    
      <category term="腾讯精选练习" scheme="http://yoursite.com/categories/%E8%85%BE%E8%AE%AF%E7%B2%BE%E9%80%89%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="栈" scheme="http://yoursite.com/tags/%E6%A0%88/"/>
    
      <category term="刷题" scheme="http://yoursite.com/tags/%E5%88%B7%E9%A2%98/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>安装selenium问题以及pip换源</title>
    <link href="http://yoursite.com/2019/07/30/%E5%AE%89%E8%A3%85selenium%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8Apip%E6%8D%A2%E6%BA%90/"/>
    <id>http://yoursite.com/2019/07/30/安装selenium问题以及pip换源/</id>
    <published>2019-07-30T05:30:00.000Z</published>
    <updated>2019-08-03T12:41:49.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装selenium问题以及pip换源"><a href="#安装selenium问题以及pip换源" class="headerlink" title="安装selenium问题以及pip换源"></a>安装selenium问题以及pip换源</h1><p>最近决定开始学习一些python爬虫的知识，结果在用pip安装一些常用第三方库的时候遇到了一些问题，在查找解决方法的过程中又看到了pip换源的内容，在此记下来供大家参考。</p><h2 id="安装selenium"><a href="#安装selenium" class="headerlink" title="安装selenium"></a>安装selenium</h2><p>使用pip安装，在命令行输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure><p>结果出错了，报错如下（前面红色部分）：</p><p><img src="/img/%E5%AE%89%E8%A3%85selenium%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8Apip%E6%8D%A2%E6%BA%90/Snipaste_2019-07-29_23-03-31.png" alt="报错信息"></p><p>查了一下发现没什么问题，结果过一会儿再试了一下，就可以装上了，如上图下半部分，就很奇怪。经过一番查找，发现可能是网不太好的原因，特别是你在学校或者公司的内网中，就有可能出现上述问题，解决方法很简单，推出内网，重新再试几次，应该就可以成功了。</p><h2 id="pip换源"><a href="#pip换源" class="headerlink" title="pip换源"></a>pip换源</h2><p>出现前面问题的根本原因是我们使用pip安装第三方库的时候，默认的源是国外的，而我们访问国外的网站比较慢，有时还会出现访问失败的情况，所以才会导致上述问题的出现。所以我们可以将pip的源换为我们国内的源，这样我们在使用pip下载第三方库的时候，就会稳定而且快很多。以下分别给出国内常用源和暂时换源以及永久换源的方法：</p><h3 id="国内常用源"><a href="#国内常用源" class="headerlink" title="国内常用源"></a>国内常用源</h3><p>1.阿里云 <a href="http://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener">http://mirrors.aliyun.com/pypi/simple/</a></p><p>2.中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.mirrors.ustc.edu.cn/simple/</a> </p><p>3.豆瓣(douban) <a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">http://pypi.douban.com/simple/</a> </p><p>4.清华大学 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple/</a></p><p>5.中国科学技术大学 <a href="http://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">http://pypi.mirrors.ustc.edu.cn/simple/</a>  </p><h3 id="暂时换源"><a href="#暂时换源" class="headerlink" title="暂时换源"></a>暂时换源</h3><p>顾名思义，你只是在下载这个库的时候用默认源不行，想换成国内源下载，那么只需要在pip安装命令后面加上 -i参数，同时在后面指定源地址即可，例子如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium -i https://pypi.tuna.tsinghua.edu.cn/simple/</span><br></pre></td></tr></table></figure><h3 id="永久换源"><a href="#永久换源" class="headerlink" title="永久换源"></a>永久换源</h3><p>有的人（比如像我一样）觉得默认源下载起来太慢了，想以后所有的库都换成国内源去下载，那么只需要修改一下pip的配置即可，具体步骤如下：（Windows环境）</p><p>第一步: win+R 输入%HOMEPATH%打开用户目录（以确保是在本机用户目录下），在此目录下创建 pip 文件夹，在 pip 目录下创建 pip.txt文件, 内容如下：（以清华的源为例，其他的源只需要修改相应的地址即可）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host = pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure><p>第二步: 保存好后修改后缀名为.ini，即此时文件名为pip.ini，Windows下会将该文件识别为配置文件。</p><p>第三步: 在系统环境变量的path变量里加上一条%HOMEPATH%\pip\pip.ini，确认设置即可。</p><p>  <img src="/img/%E5%AE%89%E8%A3%85selenium%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8Apip%E6%8D%A2%E6%BA%90/Snipaste_2019-07-30_13-21-33.png" alt="环境变量"></p><hr><p>换源以后再安装就会发现速度快很多了，基本上是秒下载安装好。至于为什么用清华的源，是因为据说清华的源是官方源的副本，每五分钟刷新一次，保证了稳和快，当然你用其他的源也是可以的，只需要改相应的地址即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装selenium问题以及pip换源&quot;&gt;&lt;a href=&quot;#安装selenium问题以及pip换源&quot; class=&quot;headerlink&quot; title=&quot;安装selenium问题以及pip换源&quot;&gt;&lt;/a&gt;安装selenium问题以及pip换源&lt;/h1&gt;&lt;p&gt;最近
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="pip" scheme="http://yoursite.com/tags/pip/"/>
    
      <category term="selenium" scheme="http://yoursite.com/tags/selenium/"/>
    
  </entry>
  
  <entry>
    <title>安装CTeX后环境变量（Path）被覆盖</title>
    <link href="http://yoursite.com/2019/06/09/%E5%AE%89%E8%A3%85CTeX%E5%90%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%88Path%EF%BC%89%E8%A2%AB%E8%A6%86%E7%9B%96/"/>
    <id>http://yoursite.com/2019/06/09/安装CTeX后环境变量（Path）被覆盖/</id>
    <published>2019-06-09T13:21:00.000Z</published>
    <updated>2019-06-09T13:42:27.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装CTeX后环境变量（Path）被覆盖"><a href="#安装CTeX后环境变量（Path）被覆盖" class="headerlink" title="安装CTeX后环境变量（Path）被覆盖"></a>安装CTeX后环境变量（Path）被覆盖</h1><p>最近因为一些原因需要在电脑上安装CTex（一个常用的论文排版工具），主要根据<a href="https://blog.csdn.net/muzhicihe/article/details/80326090" target="_blank" rel="noopener">教程一</a>和<a href="http://www.mamicode.com/info-detail-2143279.html" target="_blank" rel="noopener">教程二</a>来安装。前期一切都好，也没遇到什么问题，但是就在安装完成后，突然发现自己电脑上环境变量中Path的值被覆盖了，也就是只剩下了跟CTex相关的环境变量数据，原本的值全部不见了。如下图框选部分：</p><p><img src="/img/%E5%AE%89%E8%A3%85CTeX%E5%90%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%88Path%EF%BC%89%E8%A2%AB%E8%A6%86%E7%9B%96/1560076141824.png" alt="1560076141824"></p><p>在网上查了很久，把找到的方法挨个尝试了一遍，没有一个起作用（真的是欲哭无泪）。只好接受这个事实，希望在以后遇到由此引发的问题时能合理解决。在此记下找到的一些方法，说不定对大家有用。</p><h2 id="提前备份"><a href="#提前备份" class="headerlink" title="提前备份"></a>提前备份</h2><p>当然，最好的方式便是提前将自己的环境变量值给备份下来，以防万一。大概步骤如下：</p><ol><li>在”计算机“上右键，找到”属性“，然后点击高级系统设置。</li><li>点击“环境变量”，找到“系统变量”中的path，将里面的值拷贝出来，放到任意一个文本文件中保存。</li><li>关闭刚刚打开的窗口。双击Ctex安装包，然后按照提示，一直安装完。</li><li>完成后，按照1、2步骤找到环境变量，会发现里面的path值被Ctex覆盖了。把刚刚保存的文本放到path的最前面，然后在添加的文本后添加一个（英文的）分号，然后点击保存，确定，再关闭。</li></ol><p><strong>在此也给自己提个醒，不定时备份一下自己的重要数据，很有必要。</strong></p><h2 id="未重启通过注册表恢复"><a href="#未重启通过注册表恢复" class="headerlink" title="未重启通过注册表恢复"></a>未重启通过注册表恢复</h2><p>有些电脑本地机器的数据不会即时更新，所以你原本的环境变量<strong>可能</strong>还在你的电脑里，可以通过注册表查看，当然前提是你没有将你的电脑重启过，<strong>关机无效</strong>。（这只是可能，就像我的电脑，没有关机同样不行）操作步骤如下：</p><ol><li>按 win +R，输入 regedit以打开注册表。</li><li>找到如下项：“HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Control\Session Manager\Environment”，如果没有，可以找“HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment”，把里面的path复制过来，然后添加在系统变量的path之前。</li><li>添加时记得每一个值之间用英文的分号分隔。</li></ol><p><img src="/img/%E5%AE%89%E8%A3%85CTeX%E5%90%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%88Path%EF%BC%89%E8%A2%AB%E8%A6%86%E7%9B%96/1560086286565.png" alt="1560086286565"></p><h2 id="手动重建"><a href="#手动重建" class="headerlink" title="手动重建"></a>手动重建</h2><p>当然你可能也像我一样，上面的方法都不行，这个时候，只能手动重建你的path变量值了。在此给Windows10默认的path变量值，以及常用的环境变量值，如下：</p><p><strong>默认的：</strong></p><ul><li>%SystemRoot%\system32</li><li>%SystemRoot%</li><li>%SystemRoot%\System32\Wbem</li><li>%SYSTEMROOT%\System32\WindowsPowerShell\v1.0\</li></ul><p><strong>常用的：</strong></p><ul><li>%SYSTEMROOT%\System32\OpenSSH\</li><li>%JAVA_HOME%\bin</li><li>%JAVA_HOME%\jre\bin</li></ul><hr><p>以上就是我在这个过程中找到的一些解决办法，希望能对大家有帮助。我的电脑环境变量现在也只有重新慢慢在建立了，可能以后会遇到一些问题，但既来之，则安之，问题总是能解决的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装CTeX后环境变量（Path）被覆盖&quot;&gt;&lt;a href=&quot;#安装CTeX后环境变量（Path）被覆盖&quot; class=&quot;headerlink&quot; title=&quot;安装CTeX后环境变量（Path）被覆盖&quot;&gt;&lt;/a&gt;安装CTeX后环境变量（Path）被覆盖&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="本地电脑" scheme="http://yoursite.com/categories/%E6%9C%AC%E5%9C%B0%E7%94%B5%E8%84%91/"/>
    
    
      <category term="path" scheme="http://yoursite.com/tags/path/"/>
    
      <category term="环境变量" scheme="http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>博客搭建注意事项</title>
    <link href="http://yoursite.com/2019/06/08/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://yoursite.com/2019/06/08/博客搭建注意事项/</id>
    <published>2019-06-08T09:05:00.000Z</published>
    <updated>2019-08-03T15:07:28.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博客搭建注意事项"><a href="#博客搭建注意事项" class="headerlink" title="博客搭建注意事项"></a>博客搭建注意事项</h1><p>最近突然想搭一个真正属于自己的博客，也想慢慢开始写一点东西，所以在跟着<a href="https://blog.csdn.net/qq_36759224/article/details/82121420" target="_blank" rel="noopener">大佬的教程</a>基本搭好了自己的博客后，想将自己在这个过程中遇到的一些问题与找到的解决办法写下来。由于我前面有过搭建博客的经历，所以有些步骤我可能跳过了，从而也产生了一些我个人会遇到的问题，仅供大家参考。（本文需要和大佬的<a href="https://blog.csdn.net/qq_36759224/article/details/82121420" target="_blank" rel="noopener">原教程</a>一起搭配食用）</p><h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2><p>进去<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官网</a>图点击对应版本下载就行了，我下载的Windows 64位版本，速度相当慢，可能是因为该网站服务器在国外的原因，在此放个<a href="https://www.lanzous.com/i4i1s1c" target="_blank" rel="noopener">链接</a>（Windows 64版本）。</p><p><img src="https://pic.superbed.cn/item/5d45a18c451253d1783b5085.png" alt="node.js"></p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>分别敲入如下命令后回车，可能会无反应，但实际上已经在后台安装了，需要等一会儿便会直接显示结果，可能是因为需要安装的组件太多，时间花费较长，大概在一分钟内会有结果显示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g  </span><br><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h2 id="配置-SSH-密钥"><a href="#配置-SSH-密钥" class="headerlink" title="配置 SSH 密钥"></a>配置 SSH 密钥</h2><p>如果你以前就有将自己本地的Git和远程GitHub相连接，即已经配置过SSH密钥，那么直接跳过配置步骤进入测试步骤即可。</p><h2 id="将本地的-Hexo-文件更新到-Github-的库中"><a href="#将本地的-Hexo-文件更新到-Github-的库中" class="headerlink" title="将本地的 Hexo 文件更新到 Github 的库中"></a>将本地的 Hexo 文件更新到 Github 的库中</h2><p>在下图步骤中，我确实遇到了图示错误，此时需要再次执行 <em>npm install hexo-deployer-git –save</em> 命令，但是执行位置需改为blog下的hexo文件夹（基本上大多数命令执行的位置都在此）。</p><p><img src="https://pic.superbed.cn/item/5d45a196451253d1783b50ec.png" alt="hexo位置"></p><h2 id="在博客上发表文章"><a href="#在博客上发表文章" class="headerlink" title="在博客上发表文章"></a>在博客上发表文章</h2><p>我们都知道需要写的文章是以.md文件保存的，也就是markdown格式，所以我们需要一个markdown文本编辑器，在此推荐一个：<strong>Typora</strong>，大家可以去其 <a href="https://typora.io/" target="_blank" rel="noopener">官网</a>进行下载。</p><h2 id="为博客更换自己喜欢的主题"><a href="#为博客更换自己喜欢的主题" class="headerlink" title="为博客更换自己喜欢的主题"></a>为博客更换自己喜欢的主题</h2><p>由原教程的方法，进入 Hexo 官网的<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题专栏</a>找到你喜欢的主题项目后，根据原教程更换自己博客主题，完成以后可以根据该主题项目使用文件进行细节方面的修改。如我随机选中的一个博客<a href="https://github.com/kinggozhang/hexo-theme-ace" target="_blank" rel="noopener">主题项目</a>，会有下图所示使用方法。</p><p><img src="https://pic.superbed.cn/item/5d45a19b451253d1783b5126.png" alt="hexo主题"></p><h2 id="博客美化和实用功能的添加"><a href="#博客美化和实用功能的添加" class="headerlink" title="博客美化和实用功能的添加"></a>博客美化和实用功能的添加</h2><p>我在我的博客里面加了一些我个人比较喜欢的小功能，有些功能是我采用的主题自带的功能。</p><h3 id="浏览器网页标题恶搞"><a href="#浏览器网页标题恶搞" class="headerlink" title="浏览器网页标题恶搞"></a>浏览器网页标题恶搞</h3><p>添加教程<a href="https://blog.csdn.net/qq_36759224/article/details/85420403#font_colorFF0000___font_211" target="_blank" rel="noopener">在此</a>，需要注意的是你需要将下图位置代码改成你的网站标题logo图片名称。</p><p><img src="https://pic.superbed.cn/item/5d45a1a0451253d1783b516d.png" alt="浏览器标题"></p><h3 id="添加字数统计和阅读时长"><a href="#添加字数统计和阅读时长" class="headerlink" title="添加字数统计和阅读时长"></a>添加字数统计和阅读时长</h3><p><a href="https://blog.csdn.net/qq_36759224/article/details/85010191#font_colorFF0000___font_57" target="_blank" rel="noopener">教程链接</a>，在如下步骤时，可能会遇到你的主题下没有该文件，此时只需将框选代码加到你的<strong>文章摸板里的标题位置下面</strong>即可。</p><p><img src="https://pic1.superbed.cn/item/5d45a1a3451253d1783b51a2.png" alt="字数统计"></p><h3 id="添加网站运行时间"><a href="#添加网站运行时间" class="headerlink" title="添加网站运行时间"></a>添加网站运行时间</h3><p>这个跟着<a href="https://blog.csdn.net/qq_36759224/article/details/85010191#font_colorFF0000___font_106" target="_blank" rel="noopener">教程</a>走基本没问题，只是添加位置按照你自己的需要来即可。</p><hr><p>根据原教程搭建博客需要注意的地方大概写的差不多了，如果后续还有发现的会持续修改。本文可以说是我的第一篇博客文章，以后我也会慢慢写更多的，希望以文字来沉淀自己的所学，共勉。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;博客搭建注意事项&quot;&gt;&lt;a href=&quot;#博客搭建注意事项&quot; class=&quot;headerlink&quot; title=&quot;博客搭建注意事项&quot;&gt;&lt;/a&gt;博客搭建注意事项&lt;/h1&gt;&lt;p&gt;最近突然想搭一个真正属于自己的博客，也想慢慢开始写一点东西，所以在跟着&lt;a href=&quot;ht
      
    
    </summary>
    
      <category term="HEXO博客" scheme="http://yoursite.com/categories/HEXO%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="HEXO" scheme="http://yoursite.com/tags/HEXO/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/06/07/hello-world/"/>
    <id>http://yoursite.com/2019/06/07/hello-world/</id>
    <published>2019-06-07T10:56:30.000Z</published>
    <updated>2019-06-08T10:20:34.528Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="HEXO博客" scheme="http://yoursite.com/categories/HEXO%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="HEXO" scheme="http://yoursite.com/tags/HEXO/"/>
    
      <category term="Hello World" scheme="http://yoursite.com/tags/Hello-World/"/>
    
  </entry>
  
</feed>
